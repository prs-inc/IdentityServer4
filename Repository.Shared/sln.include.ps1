# THIS FILE IS NOT MEANT TO BE USED DIRECTLY 
# It should be included in any build for VS solutions.

Write-Host "the current location is " (Get-Location)
$rootPath = (Resolve-Path -Path '..')

# include shared functions for file system
# since this is a nested dot source it has to be done from the location of the 
# current root file
. ([System.IO.Path]::Combine($rootPath, 'Repository.Shared', 'filesystem.include.ps1'))

function Remove-CompilerFiles {
    # MSBuild Clean leaves behind files that it did not create
    Remove-Item -Path '.\src\*\bin\*' -Recurse -Force -ErrorAction SilentlyContinue
    Remove-Item -Path '.\src\*\obj\*' -Recurse -Force -ErrorAction SilentlyContinue
    
    # some sln seperate out the src and test into seperate directories
    if (Test-Path -Path '.\test') {
        Remove-Item -Path '.\test\*\bin\*' -Recurse -Force -ErrorAction SilentlyContinue
        Remove-Item -Path '.\test\*\obj\*' -Recurse -Force -ErrorAction SilentlyContinue
    }
}

function Invoke-DotNetTest {
    param (
        [string]$Project,
        [string]$VsConfiguration,
        [string]$TFM = ''
    )
    
    $csproj = (Get-ChildItem -Path ".\*\$Project" -Filter "$Project.csproj" -Recurse)

    exec {

        $args = @()

        $args += "$csproj"
        $args += "--no-build"
        $args += "--configuration"
        $args += "$VsConfiguration"
        if ($TFM -ne ''){
            $args += "--framework"
            $args += "$TFM"
        }
        $args += '--logger'
        $args += '"console;verbosity=normal"'
        
        # RunSettings
        $args += "--"
        $args += "NUnit.DisplayName=FullNameSep"
        
        Write-Host $args
        dotnet test $args
    }

}

function Package-Exe {
    param (
        [String]$Project,
        [String]$VsBinPath,
        [String]$Destination
    )

    if (!(Test-Path -Path "$Destination\bin")){
        New-Directory -Path "$Destination\bin"
    }

    Copy-Item -Path ".\src\$Project\$VsBinPath\*" -Destination $Destination -Recurse -Include "$Project.*" -Exclude "$Project.vshost.*" -Force
    Copy-Item -Path ".\src\$Project\$VsBinPath\*" -Destination "$Destination\bin" -Recurse -Exclude "$Project.*", '*.pssym' -Force
}

function Package-Directory {
    param (
        [String]$Project,
        [String]$VsBinPath,
        [String]$Destination
    )

    Write-Host "Path is .\src\$Project\$VsBinPath\*"
    Write-Host "Destination is $Destination"

    # If the destination does not exist then it needs to be created.  Not assuming we always
    # need to create it because some scripts will do that for us and will create a structure
    # they need.
    if (!(Test-Path -Path $Destination)) {
        New-Directory $Destination
    }
    
    Copy-Item -Path ".\src\$Project\$VsBinPath\*" -Destination $Destination -Recurse -Force 

    # get rid of PostSharp Symbol files, only needed for VS extension
    Get-ChildItem -Path "$Destination\*.pssym" -Recurse | Remove-Item
}

function Publish-DotNet {
    param (
        [String]$Project,
        [String]$VsConfiguration,
        [String]$Destination,
        [string]$TFM = 'netcoreapp3.1',
        [string]$RID = ''
    )

    Write-Host "dotnet publish for $Project using configuration $VsConfiguration"
    Write-Host "Destination is $Destination"
    
    New-Directory $Destination

    # Need the SolutionDir property because the .csproj files will output to 
    # $(SolutionDir).build\bin\...  Since this public target is a csproj there
    # is no $(SolutionDir) being set by MSBuild.  Need the trailing slash to
    # mimic exact path generated by MSBuild for .sln based builds.
    $slnDir = $(Resolve-Path '.')
    
    exec {
        $args = @(Combine-Paths -Paths 'src', $Project, "$Project.csproj")
        $args += "--configuration", "$VsConfiguration"
        $args += "--framework", "$TFM"
        $args += "--output", "$Destination"
        
        if ($RID -ne ''){
            $args += "--runtime", "$RID"
            # this mean the .net core runtime has to be installed on the machine these files are xcopied over to
            $args += "--self-contained", "false"
        }
        else {
            # If no RID is passed in then we can assume that the build output is good
            # and package can just use the previous build.
            $args += "--no-build"
        }
        
        if ($IsLinux){
            $args += "-p:SolutionDir=`"$slnDir/`""
        }
        else {
            # Need the \ at the end because the \" is treated by the cmd.exe as an escape of the quote - but
            # SolutionDir needs to end with a \ - so the double slash at the end of "path\foo\bar\\" is needed.
            $args += "-p:SolutionDir=`"$slnDir\\`""
        }

        Write-Host "dotnet publish $args"
        dotnet publish $args
    }
}

function Package-Web-AspNetCore {
    param (
        [String]$Project,
        [String]$VsConfiguration,
        [String]$Destination
    )

    Write-Host "Path is .\src\$Project\*"
    Write-Host "Destination is $Destination"

    New-Directory $Destination
    Write-Host "packaging exe AspNetCore for $Project"
    Package-Exe -Project $Project -VsBinPath "bin\$VsConfiguration\net472" -Destination $Destination

    # this is a VS compiler artificat used for NuGet
    Remove-Item -Path "$Destination\*.deps.json"

    # need the Web.config for IIS hosting
    Copy-Item -Path ".\src\$Project\Web.config" -Destination "$Destination\Web.config"

    # if this is just a web api or has no UI this folder might not exist
    if (Test-Path -Path ".\src\$Project\wwwroot") {
        # wwwroot contains the static assets
        Copy-Item -Path ".\src\$Project\wwwroot" -Destination $Destination -Recurse -Force
    }

    Write-Host "update web.config AspNetCore for $Project"
    Update-WebConfig-AspNetCore -Project $Project -Path "$Destination\Web.config" -VsConfiguration $VsConfiguration
}

function Update-WebConfig-AspNetCore {
    param (
        [string]$Project,
        [string]$Path,
        [string]$VsConfiguration
    )

    # need to use Resolve-Path because the working directory used by Xml.Save is
    # different than the current powershell directory
    $configPath = (Resolve-Path -Path $Path)
    $xml = [xml](Get-Content -Path $configPath)

    # <aspNetCore processPath="%LAUNCHER_PATH%" arguments="%LAUNCHER_ARGS%" stdoutLogEnabled="false">
    $node = $xml.SelectSingleNode("/configuration/system.webServer/aspNetCore")
    $node.SetAttribute("processPath", ".\$Project.exe")
    $node.SetAttribute("arguments", "")

    $xml.Save($configPath)
}

function Package-Web {
    param (
        [String]$Project,
        [String]$VsConfiguration,
        [String]$Destination
    )

    Write-Host "Path is .\src\$Project\*"
    Write-Host "Destination is $Destination"

    New-Directory $Destination
    Copy-Item -Path ".\src\$Project\*" -Destination $Destination -Recurse -Force `
        -Exclude 'node_modules', 'obj', 'Properties', 'Web References', '*.build', '*.cs', '*.cd', '*.csproj*', '*.pssym', '*.resx', '*.targets', 'gulpfile.js', 'json.config', 'packages.config', 'tsconfig.json'

    # get all of the directories, sorted by FullName so that child directories appear
    # before their parent directory
    $dirs = Get-ChildItem -Path $Destination -Directory -Recurse | 
        Sort-Object -Descending -Property FullName

    # iterate through the sorted directories to find any empty ones and delete it
    # if the directory is empty
    foreach($_ in $dirs) {
        $info = (Get-ChildItem -Path $_.FullName -Recurse -File) | Measure-Object
        
        if ($info.Count -eq 0) {
            Write-Host "removing empty directory $_"
            Remove-Item -Path $_.FullName -Force
        }
    }

    Update-WebConfig -Path "$Destination\Web.config" -VsConfiguration $VsConfiguration

}

function Update-WebConfig {
    param (
        [string]$Path,
        [string]$VsConfiguration
    )

    if ($VsConfiguration -eq 'Release'){
        # need to use Resolve-Path because the working directory used by Xml.Save is
        # different than the current powershell directory
        $configPath = (Resolve-Path -Path $Path)
        $xml = [xml](Get-Content -Path $configPath)

        $node = $xml.SelectSingleNode("/configuration/system.web/compilation")
        $node.SetAttribute("debug", "false")

        $xml.Save($configPath)
    }
}

function Stop-IISExpress {
    param (
        [Parameter(Mandatory=$true)]
        [string]
        $Project
    )

    # have to use Get-CimInstance instead of Get-Process because that is the
    # only way to get the command line used to launch the executable
    $process = Get-CimInstance Win32_Process -Filter "name = 'iisexpress.exe'"
    foreach($proc in $process)
    {
        $cmdLine = $proc.CommandLine
        if (!$cmdLine){
            continue;
        }
        $expPid = $proc.ProcessId
        if ($cmdLine.Contains("$Project")) {
            Write-Host "stopping the IISExpress process for $Project with the PID $expPid"
            Stop-Process -Id $expPid -Force
        }
    }
}

function Config-IISExpress {
    param (
        [Parameter(Mandatory=$true)]
        [string]
        $Solution
    )

    $configPath = (Resolve-Path -Path "$rootPath\iisexpress.config")

    Write-Host $rootPath
    Write-Host $configPath

    # if the .vs directory does not exists want to create it and create
    # it with the hidden attribute just like VS would the first time it
    # is opened
    if (!(Test-Path -Path '.vs')) {
        $d = New-Item -Path '.vs' -Type 'Directory'
        $d.Attributes = $d.Attributes -bor 'hidden'
    }
    
    # the .vs directory can be created when Visual Studio is opened but if
    # there is no web application then the config directory will not be made
    if (!(Test-Path -Path '.vs\config')) {
        New-Item -Path '.vs\config' -Type 'Directory'
    }

    # replace the [ROOT.DIR] text and copy the output to the location visual studio expects
    (Get-Content -Path $configPath) |
        ForEach-Object {$_ -Replace '\[ROOT.DIR\]', "$rootPath"} |
        Out-File -FilePath "$rootPath\$Solution\.vs\config\applicationhost.config" -Encoding utf8 -Force
    
    # if the JetBrains Rider IDE is being used then it will default to this location for its 
    # default config of the debugger
    if (Test-Path -Path '.idea\config') {
        Copy-Item `
            -Path "$rootPath\$Solution\.vs\config\applicationhost.config" `
            -Destination "$rootPath\$Solution\.idea\config\applicationhost.config"
    }
}

function Start-IISExpress {
    param (
        [Parameter(Mandatory=$true)]
        [string]
        $Solution,
        
        [Parameter(Mandatory=$true)]
        [string]
        $Project,

        [Parameter(Mandatory=$false)]
        [ValidateSet('x86', 'x64')]
        [string]$Bitness = 'x64',
    
        [Parameter(Mandatory=$false)]
        [string]$LauncherPath = '',

        [Parameter(Mandatory=$false)]
        [string]$LauncherArgs = ' '
    )

    Stop-IISExpress -Project $Project
    
    $rootPath = (Resolve-Path -Path '..')
    $iisexp = 'C:\Program Files\IIS Express\iisexpress.exe'
    if ($Bitness -eq 'x86'){
        $iisexp = 'C:\Program Files (x86)\IIS Express\iisexpress.exe'
    }

    $workingDir = "$rootPath\$Solution\src\$Project"
    $arguments = "/config:$rootPath\$Solution\.vs\config\applicationhost.config /site:`"$Project`""

    # this will need to be fixed up to only have a single application per IIS Express instance because
    # of this environment variable used to startup the aspnetcore module.  With IIS 10 the AppPool needs
    # the <environmentVariables><add name="" value="" /> added for these two.
    if ($LauncherPath -ne ''){
        $Env:LAUNCHER_PATH = $LauncherPath
        $Env:LAUNCHER_ARGS = $LauncherArgs
    }

    $proc = Start-Process -FilePath $iisexp `
        -ArgumentList $arguments `
        -WorkingDirectory "$workingDir" `
        -WindowStyle Hidden `
        -PassThru 
    
    Write-Host "started IISExpress for $Project in $Solution with PID $($proc.Id)"
}

function Zip-Directory {
    param (
        [string]$Path,
        [string]$Destination
    )

    $exe = "C:\Program Files\7-Zip\7z.exe"
    
    if ($IsLinux){
        $exe = "7z"
    }
    
    exec {
        & $exe a $Destination (Join-Path -Path $Path -ChildPath '*')
    }
}


function Install-NPM {
    
    Write-Host "running npm install"
    if ($IsLinux -eq $true){
        exec {
            & npm install 
        }
    }
    else {
        exec {
            #
            # NPM will write warnings to the STDERR.  I tried to do the interception in PowerShell as suggested at
            # https://stackoverflow.com/questions/34917977/disable-npm-warnings-as-errors-build-definition-tfs
            # But NPM was still writing to the STDERR before sending the results to PowerShell so CC.NET was 
            # marking the build as failed.  
            #
            # Using --loglevel to filter out WARN from the output
            & npm install --loglevel=error
        }
    }

}

function Invoke-Webpack {
    param (
        [string]$Mode
    )

    $webpackPath = Join-Path -Path "." -ChildPath "node_modules\webpack\bin\webpack"
    exec {
        node "$webpackPath" --mode=$Mode
    }
}

function Remove-DuplicateFiles {
    param (
        [string]$Path,
        [string]$CompareToPath,
        [string]$IgnorePrefix = ''
    )
    
    # the ignore prefix can be used with Firm specific assemblies (SAPC.CMS/SIPWC.CMS).  It is important to use
    # because in order to run Workpoint those Firm specific assemblies have to be copied to CMS\Workpoint.NET\bin\cms
    # That would cause them to be picked up as duplicate assemblies when building the package directories for the
    # Firm specific files.  This does introduce a problem that will be seen when the Firm assemblies add references
    # to other DLLs.  When that happens we can switch IgnorePrefix over to an array or look for an alternate approach.

    $p1 = (Resolve-Path -Path $Path)
    $p2 = (Resolve-Path -Path $CompareToPath)

    Get-ChildItem -Path "$p1" -File -Recurse |
        ForEach-Object -Process {
            $testPath = $_.FullName.Replace($p1, $p2)

            if (Test-Path -Path $testPath){
                if (($IgnorePrefix -ne '') -and ($_.Name.StartsWith($IgnorePrefix))) {
                    Write-Host "ignoring duplicate $( $_.FullName ) because of prefix $IgnorePrefix"
                }
                else {
                    Remove-Item -Path $_.FullName
                    Write-Host "deleted duplicate $( $_.FullName )"
                }
            }
        }
}

function Clean-DotNet {
    param(
        [string]$Solution,
        [string]$VsConfiguration,
        [string]$Platform = 'Any CPU'
    )

    if (Test-Path -Path '.\.build') {
        Remove-Item -Path .\.build -Recurse -Force -ErrorAction SilentlyContinue
    }

    # MSBuild will not get rid of obj files 
    Remove-CompilerFiles

    exec {
        dotnet clean "$Solution.sln" `
            --configuration $VsConfiguration 
    }
}

function Build-DotNet {
    param(
        [string]$Solution,
        [string]$VsConfiguration,
        [string]$Platform = 'Any CPU'
    )

    #
    # CreateDocumentationFile - using that name because it is supporting the current MSBuild, 
    # the .NET Core SDK property of GenerateDocumentationFile, and not generating Xml Doc file 
    # for tests projects.  If the tests projects was not around then we would just use the property
    # GenerateDocumenationFile and skip the conditional <PropertyGroup> in the csproj file.

    exec {
        dotnet build "$Solution.sln" `
            --configuration $VsConfiguration `
            -p:Platform="$Platform" `
            -p:CreateDocumentationFile="true" `
            -p:GeneratePackageOnBuild="true"
    }
}